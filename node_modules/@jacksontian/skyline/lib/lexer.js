'use strict';

class Lexer {
  constructor(source, filename, offset = {}) {
    this.source = source;
    this.filename = filename;

    this.index = offset.index || -1;
    /**
     * @brief 这个 peek 跟 C++ cin.peek() 是一样的，表示预读读入一个字符
     */
    this.peek = ' ';
    this.words = new Map();
    this.line = offset.line || 1;
    this.column = offset.column || 0;
  }

  // read and consume a char
  getch() {
    if (this.peek === '\n') {
      // line number
      this.line++;
      this.column = 0;
    }
    this.index++;
    this.column++;
    this.peek = this.source[this.index]; // 其它返回实际字节值
  }

  // read a char by offset
  readch(i = 0) {
    // 只读取，不消费
    return this.source[this.index + i];
  }

  ungetch() {
    this.index--;
    this.column--;
    this.peek = this.source[this.index]; // 其它返回实际字节值
  }

  /**
   * @brief 这个表示往 Lexer 里面注册 token 关键字
   */
  reserve(word) {
    if (this.words.has(word.lexeme)) {
      throw new Error(`duplicate reserved word: ${word.lexeme}`);
    }
    this.words.set(word.lexeme, word);
  }

  skipWhitespaces() {
    // 忽略空格,和TAB ch =='\n'
    while (this.peek === ' ' || this.peek === '\t' ||
      this.peek === '\n' || this.peek === '\r') {
      this.getch();
    }
  }
}

module.exports = Lexer;
